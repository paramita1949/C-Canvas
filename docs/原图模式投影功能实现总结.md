# 原图模式投影功能实现总结

## 一、问题背景

在实现原图模式的投影功能时,遇到了投影屏幕显示不正确的问题:
- 图片被过度拉伸或变形
- 图片无法完整显示
- 位置偏移不正确

经过多次调试和深入分析Python源代码,最终找到了根本原因并成功解决。

## 二、核心问题分析

### 2.1 DPI缩放问题

**关键发现**: WPF使用**设备独立单位(DIU)**,而不是物理像素!

在高DPI屏幕(如200%缩放)上:
- 屏幕物理分辨率: `3840x2160`
- ScrollViewer的DIU尺寸: `1920x1080` (ActualWidth/ActualHeight)
- 两者比例: `2:1` (200% DPI缩放)

**错误做法**:
```csharp
// ❌ 使用屏幕物理分辨率计算图片尺寸
double canvasWidth = screenWidth;  // 3840
double canvasHeight = screenHeight; // 2160
// 结果: 图片尺寸 = 3840x2160,但WPF布局系统期望1920x1080!
```

**正确做法**:
```csharp
// ✅ 使用ScrollViewer的ActualWidth/ActualHeight (DIU单位)
double canvasWidth = _projectionScrollViewer?.ActualWidth ?? screenWidth;
double canvasHeight = _projectionScrollViewer?.ActualHeight ?? screenHeight;
// 结果: 图片尺寸 = 1920x1080,与WPF布局系统一致!
```

### 2.2 定位方式问题

**Python的定位逻辑**:
```python
# 计算居中位置
x = max(0, (screen_width - new_width) // 2)
y = max(0, (screen_height - new_height) // 2)

# 使用绝对坐标定位
canvas.create_image(x, y, anchor=tk.NW, image=photo)
```

**WPF的错误做法**:
```csharp
// ❌ 使用WPF的对齐属性(Center/Stretch)
_projectionImageControl.HorizontalAlignment = HorizontalAlignment.Center;
_projectionImageControl.VerticalAlignment = VerticalAlignment.Center;
// 问题: 在某些情况下会导致图片被拉伸变形
```

**WPF的正确做法**:
```csharp
// ✅ 模仿Python的绝对坐标定位,使用Margin
double x = Math.Max(0, (containerWidth - newWidth) / 2.0);
double y = Math.Max(0, (containerHeight - newHeight) / 2.0);

_projectionImageControl.HorizontalAlignment = HorizontalAlignment.Left;
_projectionImageControl.VerticalAlignment = VerticalAlignment.Top;
_projectionImageControl.Margin = new Thickness(x, y, 0, 0);
```

## 三、最终解决方案

### 3.1 图片尺寸计算

```csharp
private (int width, int height) CalculateImageSize(int screenWidth, int screenHeight)
{
    // 关键: WPF使用设备独立单位(DIU),需要考虑DPI缩放
    // 获取投影ScrollViewer的实际DIU尺寸(如果已渲染)
    double canvasWidth = _projectionScrollViewer?.ActualWidth ?? screenWidth;
    double canvasHeight = _projectionScrollViewer?.ActualHeight ?? screenHeight;
    
    // 如果ScrollViewer还没有渲染,则假设使用屏幕物理尺寸
    if (canvasWidth <= 0) canvasWidth = screenWidth;
    if (canvasHeight <= 0) canvasHeight = screenHeight;
    
    if (_isOriginalMode)
    {
        // 原图模式：根据显示模式智能缩放
        double widthRatio = canvasWidth / _currentImage.Width;
        double heightRatio = canvasHeight / _currentImage.Height;
        
        double scaleRatio;
        if (_originalDisplayMode == OriginalDisplayMode.Stretch)
        {
            // 拉伸模式：宽度填满,高度按比例
            scaleRatio = heightRatio;
            newWidth = (int)canvasWidth;
            newHeight = (int)(_currentImage.Height * scaleRatio);
        }
        else
        {
            // 适中模式：高度填满,宽度按比例
            scaleRatio = Math.Min(widthRatio, heightRatio);
            newWidth = (int)(_currentImage.Width * scaleRatio);
            newHeight = (int)(_currentImage.Height * scaleRatio);
        }
    }
    
    return (newWidth, newHeight);
}
```

### 3.2 图片定位

```csharp
// 获取投影ScrollViewer的实际DIU尺寸用于居中计算
double containerWidth = _projectionScrollViewer?.ActualWidth ?? screenWidth;
double containerHeight = _projectionScrollViewer?.ActualHeight ?? screenHeight;
if (containerWidth <= 0) containerWidth = screenWidth;
if (containerHeight <= 0) containerHeight = screenHeight;

// 计算居中位置 (完全模仿Python的逻辑,但使用DIU尺寸)
double x = Math.Max(0, (containerWidth - newWidth) / 2.0);
double y = Math.Max(0, (containerHeight - newHeight) / 2.0);

// 设置对齐方式和位置 (模仿Python: anchor=tk.NW + 计算的x,y坐标)
_projectionImageControl.HorizontalAlignment = HorizontalAlignment.Left;
_projectionImageControl.VerticalAlignment = VerticalAlignment.Top;

if (_isOriginalMode)
{
    // 原图模式: 水平和垂直都居中 (Python: x=居中, y=居中)
    _projectionImageControl.Margin = new Thickness(x, y, 0, 0);
}
else
{
    // 正常模式: 水平居中,垂直顶部 (Python: x=居中, y=0)
    _projectionImageControl.Margin = new Thickness(x, 0, 0, 0);
}
```

## 四、原图模式显示逻辑

### 4.1 拉伸模式(Stretch)

**目标**: 图片宽度填满投影屏幕

**实现**:
- 图片宽度 = ScrollViewer的ActualWidth (DIU)
- 图片高度 = 按比例缩放
- 水平偏移 = 0 (宽度已填满)
- 垂直偏移 = (容器高度 - 图片高度) / 2 (上下居中)

**预期效果**:
- 图片宽度填满屏幕
- 图片上下可能有黑边(如果图片高度 < 屏幕高度)

### 4.2 适中模式(Fit)

**目标**: 图片完整显示,不裁切

**实现**:
- 缩放比例 = Min(宽度比, 高度比)
- 图片宽度 = 原图宽度 × 缩放比例
- 图片高度 = 原图高度 × 缩放比例
- 水平偏移 = (容器宽度 - 图片宽度) / 2 (左右居中)
- 垂直偏移 = (容器高度 - 图片高度) / 2 (上下居中)

**预期效果**:
- 图片完整显示,不裁切
- 图片可能左右或上下有黑边

## 五、关键经验教训

### 5.1 深入研究源代码的重要性

**教训**: 如果一开始就深入研究Python源代码,而不是凭经验猜测,就能避免走很多弯路。

**Python源代码关键点**:
```python
# projection_manager.py, line 740-753
# 计算居中位置 - 水平和垂直都居中
x = max(0, (screen_width - new_width) // 2)
y = max(0, (screen_height - new_height) // 2)

# 显示新图片 - 在原图模式下居中显示
if self.main_app.original_mode:
    self.second_image_on_canvas = self.second_canvas.create_image(
        x, y, anchor=tk.NW, image=self.second_photo
    )
else:
    # 正常模式保持原有逻辑（顶部显示）
    self.second_image_on_canvas = self.second_canvas.create_image(
        x, 0, anchor=tk.NW, image=self.second_photo
    )
```

**关键发现**:
1. Python使用**绝对坐标定位**,不是对齐属性
2. 原图模式: `x=居中, y=居中`
3. 正常模式: `x=居中, y=0`

### 5.2 WPF与Tkinter的差异

| 特性 | Tkinter | WPF |
|------|---------|-----|
| 坐标系统 | 绝对像素坐标 | 设备独立单位(DIU) |
| 定位方式 | `create_image(x, y)` | `Margin` + `HorizontalAlignment.Left/Top` |
| DPI缩放 | 不影响坐标 | 自动缩放(200% DPI → 1/2尺寸) |
| 布局单位 | 物理像素 | DIU (与DPI无关) |

**关键**: 不能直接翻译Tkinter代码为WPF,需要理解底层逻辑并适配WPF的布局系统!

### 5.3 调试技巧

**有效的调试日志**:
```csharp
System.Diagnostics.Debug.WriteLine($"  📐 画布尺寸: 投影ScrollViewer={canvasWidth:F0}x{canvasHeight:F0} DIU (屏幕物理={screenWidth}x{screenHeight})");
System.Diagnostics.Debug.WriteLine($"  📍 原图模式定位: 容器={containerWidth:F0}x{containerHeight:F0}, 图片={newWidth}x{newHeight}, 偏移=({x:F0},{y:F0})");
```

**关键信息**:
- ScrollViewer的DIU尺寸
- 屏幕物理尺寸
- 图片尺寸
- 计算的偏移量

通过对比这些数据,可以快速定位问题!

## 六、后续优化建议

### 6.1 性能优化

- [ ] 缓存DPI缩放因子,避免每次都查询ScrollViewer
- [ ] 考虑使用GPU加速渲染(ComputeSharp.D2D1)

### 6.2 功能扩展

- [ ] 实现全局热键支持(PageUp/PageDown/ESC)
- [ ] 实现媒体播放投影(视频/音频)
- [ ] 支持多投影屏幕同时投影

### 6.3 代码重构

- [ ] 提取DPI缩放相关逻辑到独立的Helper类
- [ ] 统一主屏幕和投影屏幕的图片处理逻辑

## 七、总结

通过深入研究Python源代码,发现了WPF投影显示问题的根本原因:
1. **DPI缩放**: 必须使用ScrollViewer的ActualWidth/ActualHeight (DIU单位)
2. **定位方式**: 必须使用Margin + Left/Top对齐,模仿Python的绝对坐标定位

**核心原则**: 
- 理解框架差异,不要直接翻译代码
- 深入研究源代码,理解底层逻辑
- 充分利用调试日志,快速定位问题

**最终效果**: 
投影功能现在完全正常,拉伸/适中模式都能正确显示!

---

**创建日期**: 2025-10-10  
**作者**: AI Assistant  
**版本**: 1.0

