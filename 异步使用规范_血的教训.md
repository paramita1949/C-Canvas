# WPF异步使用规范 - 血的教训

**日期**：2025-10-17  
**教训来源**：投影显示旧图Bug

---

## 🚨 核心规则

### ⛔ 默认禁止使用 InvokeAsync

**除非有特殊原因并明确注释，否则一律使用 `Dispatcher.Invoke()`**

---

## 💔 血的教训：投影显示旧图Bug

### 问题描述
为了"优化"滚动流畅性，将 `PreRenderProjectionAsync()` 从 `Dispatcher.Invoke` 改为 `Dispatcher.InvokeAsync`，导致：

1. **快速切换图片时**：用户连续按键切换图片
2. **任务排队积压**：每次PreRender任务都加入Dispatcher队列
3. **显示旧图**：主屏幕已显示图片9，投影还在渲染图片7
4. **延迟严重**：最长延迟达到 **248ms**

### Bug日志
```
16:07:40:921  主屏幕切换到图片8
16:07:41:169  投影才开始渲染（延迟248ms）← 这时主屏幕可能已经到图片9了
```

### 根本原因
`InvokeAsync` 将任务加入队列，快速操作时：
- ❌ 任务积压，延迟执行
- ❌ 执行旧任务时，状态已经变化
- ❌ 显示内容与实际状态不一致

---

## 📋 正确的异步使用规范

### ❌ 禁止使用 InvokeAsync 的场景

#### 1. UI状态同步
```csharp
// ❌ 错误：会显示旧状态
public async void UpdateProjection()
{
    await Dispatcher.InvokeAsync(() => {
        ShowImage(currentImage);  // 快速切换时currentImage已经变了
    });
}

// ✅ 正确：立即同步
public void UpdateProjection()
{
    Dispatcher.Invoke(() => {
        ShowImage(currentImage);
    });
}
```

#### 2. 需要保证执行顺序
```csharp
// ❌ 错误：顺序可能乱
public async void LoadAndShow()
{
    await Dispatcher.InvokeAsync(() => Load());
    await Dispatcher.InvokeAsync(() => Show());  // Load可能还没执行完
}

// ✅ 正确：保证顺序
public void LoadAndShow()
{
    Dispatcher.Invoke(() => {
        Load();
        Show();
    });
}
```

#### 3. 对象状态一致性
```csharp
// ❌ 错误：状态可能不一致
public async void UpdateState()
{
    _state = NewState;
    await Dispatcher.InvokeAsync(() => {
        UpdateUI(_state);  // _state可能又被改了
    });
}

// ✅ 正确：确保一致
public void UpdateState()
{
    var capturedState = NewState;
    _state = capturedState;
    Dispatcher.Invoke(() => {
        UpdateUI(capturedState);
    });
}
```

---

### ✅ 允许使用 InvokeAsync 的特殊情况

#### 1. 低频且不影响显示的操作
```csharp
// ✅ 可以：初始化操作，只执行一次
private async void InitializeComboBox()
{
    // 明确注释原因
    // 此操作仅初始化时执行一次，不影响主要功能
    await Dispatcher.InvokeAsync(() => {
        comboBox.Items.Clear();
        // ...
    });
}
```

#### 2. 纯后台任务（不是UI操作）
```csharp
// ✅ 可以：真正的后台任务
private async void LoadDataAsync()
{
    await Task.Run(() => {
        // 后台加载数据
        var data = LoadFromDatabase();
    });
    
    // UI更新用Invoke
    Dispatcher.Invoke(() => {
        DisplayData(data);
    });
}
```

#### 3. 已确认不会积压的操作
```csharp
// ✅ 可以：有节流且不影响正确性
private async void OnLowPriorityUpdate()
{
    // 明确注释：
    // 1. 有50ms节流
    // 2. 不影响主要功能正确性
    // 3. 仅用于辅助显示
    if (DateTime.Now - _lastUpdate < TimeSpan.FromMilliseconds(50))
        return;
    
    await Dispatcher.InvokeAsync(() => {
        UpdateSecondaryUI();
    });
}
```

---

## 📊 性能对比

### Invoke vs InvokeAsync

| 指标 | Invoke (同步) | InvokeAsync (异步) |
|-----|--------------|-------------------|
| **阻塞时间** | 50-160ms | 0ms |
| **延迟时间** | 0ms | 0-500ms+ (积压时) |
| **正确性** | ✅ 保证 | ⚠️ 可能错误 |
| **顺序性** | ✅ 保证 | ❌ 不保证 |
| **适用场景** | 默认选择 | 特殊情况 |

### 结论
- **Invoke阻塞**：50-160ms用户几乎感觉不到
- **InvokeAsync延迟**：快速操作时积压严重，影响正确性
- **优先级**：**正确性 > 理论上的流畅性**

---

## 🔍 代码审查清单

在代码审查时，检查：

- [ ] **所有 Dispatcher 调用默认使用 Invoke**
- [ ] **使用 InvokeAsync 的地方有明确注释说明原因**
- [ ] **快速操作场景下不会导致任务积压**
- [ ] **显示内容的正确性得到保证**
- [ ] **没有因为"性能优化"而牺牲正确性**

---

## 🎯 实际案例分析

### 案例1：投影渲染（本次Bug）
```csharp
// ❌ 错误实现
public async Task PreRenderProjectionAsync()
{
    await Dispatcher.InvokeAsync(() => {
        // 渲染并显示投影
        RenderAndShowProjection();
    });
}
// 问题：快速切换时任务积压，显示旧图

// ✅ 正确实现
public Task PreRenderProjectionAsync()
{
    Dispatcher.Invoke(() => {
        // 渲染并显示投影
        RenderAndShowProjection();
    });
    return Task.CompletedTask;
}
// 优点：立即执行，显示正确
```

### 案例2：滚动同步
```csharp
// ❌ 错误实现
public async void SyncScroll()
{
    await Dispatcher.InvokeAsync(() => {
        // 同步滚动位置
        projectionScroll.ScrollTo(mainScroll.Position);
    });
}
// 问题：快速滚动时积压，位置不同步

// ✅ 正确实现
public void SyncScroll()
{
    // 有节流机制（50ms），防止过度调用
    if (DateTime.Now - _lastSync < TimeSpan.FromMilliseconds(50))
        return;
    
    Dispatcher.Invoke(() => {
        // 同步滚动位置
        projectionScroll.ScrollTo(mainScroll.Position);
    });
}
// 优点：节流+立即执行，平衡性能和正确性
```

### 案例3：键盘导航
```csharp
// ❌ 错误实现
private async void OnKeyDown()
{
    await Dispatcher.InvokeAsync(() => {
        SwitchToNextImage();
    });
}
// 问题：快速按键时积压，切换滞后

// ✅ 正确实现
private void OnKeyDown()
{
    Dispatcher.Invoke(() => {
        SwitchToNextImage();
    });
}
// 优点：立即响应，用户体验好
```

---

## 📝 修改历史

### 第一次优化（错误）
**时间**：2025-10-17 15:00  
**目的**：优化滚动流畅性  
**修改**：将4个方法改为 InvokeAsync
- PreRenderProjectionAsync
- SyncProjectionScroll
- ResetProjectionScroll
- NavigateToPreviousImage/Next

**结果**：❌ 导致投影显示旧图Bug

### 第二次修复（正确）
**时间**：2025-10-17 16:30  
**目的**：修复显示旧图问题  
**修改**：将所有方法改回 Invoke

**结果**：✅ 问题解决，显示正确

---

## 🎓 经验总结

### 1. 正确性优先
- **永远不要为了理论上的性能优化而牺牲正确性**
- **用户宁愿等50ms，也不要看到错误的内容**

### 2. 充分测试
- **"优化"后必须充分测试快速操作场景**
- **不要假设异步一定比同步好**

### 3. 理解机制
- **InvokeAsync ≠ 更快，可能更慢**
- **理解 Dispatcher 队列机制**
- **理解任务积压的后果**

### 4. 遵守规范
- **默认使用 Invoke**
- **特殊情况必须注释原因**
- **代码审查严格检查**

---

## 🚀 最佳实践

### DO（推荐）
✅ 默认使用 `Dispatcher.Invoke()`  
✅ 需要异步时明确注释原因  
✅ 使用节流机制减少调用频率  
✅ 充分测试快速操作场景  
✅ 优先保证正确性  

### DON'T（禁止）
❌ 随意使用 `InvokeAsync`  
❌ 为了"优化"而牺牲正确性  
❌ 不测试就上线"优化"  
❌ 假设异步一定更好  
❌ 忽略任务积压问题  

---

**记住**：过早优化是万恶之源！正确性永远是第一位的！

---

**文档维护**：遇到新的异步问题时更新此文档  
**最后更新**：2025-10-17  
**下次审查**：2025-11-17

