2025.10.17
--------------------------

V4.1.0 (开发中)
♻️ 重构：统一字段命名规范（阶段一-Week1完成）

1、完成内容
   ✅ **Day 1-2**：Manager类字段重命名（11个）
      - _dbManager
      - _configManager
      - _importManager
      - _imageSaveManager
      - _searchManager
      - _sortManager
      - _projectionManager
      - _originalManager
      - _preloadCacheManager
      - _videoPlayerManager
      - _globalHotKeyManager
   
   ✅ **Day 3-4**：核心功能字段重命名（15个）
      - _imageProcessor
      - _imagePath
      - _currentZoom
      - _isDragging
      - _dragStartPoint
      - _isColorEffectEnabled
      - _currentTargetColor
      - _currentTargetColorName
      - _currentFolderId
      - _projectTreeItems
      - _currentImageId
      - _originalMode
      - _originalDisplayMode
      - _mainVideoView
      - _isUpdatingProgress
   
   ✅ **Day 5**：其他字段重命名（8个）
      - _draggedItem
      - _dragOverItem
      - _isDragInProgress
      - _pendingProjectionVideoPath
      - _projectionTimeoutTimer
      - _lastPlayModeClickTime
      - _lastMediaPrevClickTime
      - _lastMediaNextClickTime

2、技术细节
   - **总计**：34个私有字段统一添加下划线前缀
   - **影响文件**：
     * UI/MainWindow.xaml.cs (主文件)
     * UI/MainWindow.Keyframe.cs (partial)
     * UI/MainWindow.Original.cs (partial)
     * UI/MainWindow.TextEditor.cs (partial)
   - **命名规范**：所有私有字段统一使用 `_camelCase` 格式
   - **编译测试**：Debug ✓ Release ✓

3、下一步计划
   - Week 2: 提取魔法数字为常量，统一异步方法命名
   - 后续：开始MainWindow拆分工作

--------------------------

V4.0.9
🐛 修复ESC键停止视频播放后界面未重置的问题
1、问题描述
   - **现象**：从图片文件切换到媒体播放，按ESC键停止播放后，界面未重置
   - **复现步骤**：
     1. 当前显示图片文件
     2. 切换到视频或音频文件（进入媒体播放模式）
     3. 按ESC键停止播放
     4. 视频播放区域和媒体控制栏仍然显示，没有隐藏
   - **影响范围**：仅影响ESC键停止播放的情况，手动切换到图片文件正常

2、问题原因（通过调试日志定位）
   - **调试发现的关键问题**：`Window_PreviewKeyDown()` 中的ESC键处理逻辑错误 (第4187-4239行)
     * 条件判断：`if (projectionManager != null)` 就调用 `CloseProjection()`
     * `CloseProjection()` 无论投影是否开启，都返回 `true`（除非异常）
     * 导致 `handled = true`，跳过了后续的视频停止处理
     * **实际情况**：`videoPlayerManager.IsPlaying: True`，但被 `handled` 标记阻止了
   - **代码位置1**：`UI/MainWindow.xaml.cs` 第638-664行（全局热键ESC处理）
     * 只调用了 `videoPlayerManager.Stop()` 停止播放
     * 没有调用 `SwitchToImageMode()` 来重置界面
     * 导致 `VideoContainer` 和 `MediaPlayerPanel` 仍然可见
   - **代码位置2**：`SwitchToImageMode()` 方法 (第5653-5669行)
     * 只隐藏了视频容器和媒体控制栏
     * 没有清空图片显示
     * 导致停止播放后，界面显示之前加载的图片1
   - **布局结构**：
     * `ImageScrollViewer`（图片显示）和 `VideoContainer`（视频显示）是并列的
     * 隐藏 `VideoContainer` 后，会露出底层的 `ImageDisplay`
     * 如果 `ImageDisplay` 中有之前的图片，就会显示出来

3、修复方案
   - **修改点1（关键修复）**：`Window_PreviewKeyDown()` 中的ESC键处理 (第4199-4213行)
     * **问题**：原逻辑 `if (projectionManager != null)` 就调用 `CloseProjection()`
     * **修复**：改为 `if (projectionManager != null && projectionManager.IsProjectionActive)`
     * **效果**：只有在投影真正激活时才尝试关闭投影
     * **原因**：`CloseProjection()` 总是返回 `true`，导致 `handled=true` 阻止后续处理
     * 适用场景：非投影模式下按ESC键停止视频播放
   - **修改点2**：`EnableGlobalHotKeys()` 中的ESC键处理 (第647-652行)
     * 将 `videoPlayerManager.Stop();` 替换为 `SwitchToImageMode();`
     * 适用场景：投影模式下按ESC键停止视频播放
   - **修改点3**：`SwitchToImageMode()` 方法 (第5656-5693行)
     * 在隐藏视频容器和媒体控制栏后，增加 `ClearImageDisplay()` 调用
     * `ClearImageDisplay()` 会清空 `ImageDisplay` 的内容，避免显示之前的图片
   - **完整的重置流程**：
     1. 调用 `videoPlayerManager.Stop()` 停止播放
     2. 隐藏 `VideoContainer` (视频播放区域)
     3. 隐藏 `MediaPlayerPanel` (媒体控制栏)
     4. 调用 `ClearImageDisplay()` 清空图片显示
     * 确保界面完全重置，不显示任何内容（黑屏状态）
   - **调试信息**：
     * 在 `SwitchToImageMode()`、`ClearImageDisplay()` 和ESC键处理中添加详细日志
     * 帮助快速定位问题（如本次通过日志发现 `handled` 被误设置）

4、测试验证
   - ✅ 图片1 → 视频 → ESC（非投影模式）：显示黑屏，不显示图片1
   - ✅ 图片1 → 音频 → ESC（非投影模式）：显示黑屏，不显示图片1
   - ✅ 图片1 → 视频 → 开启投影 → ESC：先关闭投影，视频继续播放
   - ✅ 图片1 → 视频 → 开启投影 → ESC（再次）：停止播放并清空显示
   - ✅ 图片1 → 视频 → ESC → 切换图片2：正常显示图片2
   - ✅ 手动切换图片文件：调用 `SwitchToImageMode()` 后立即加载新图片
   
5、相关文件
   - `UI/MainWindow.xaml.cs`

V4.0.8
🐛 修复滚动函数被意外覆盖的问题
1、问题描述
   - **现象**：修改滚动速度（运动时间）时，滚动函数会被重置为贝塞尔曲线
   - **复现步骤**：
     1. 设置滚动函数为"线性滚动"或其他缓动函数
     2. 修改滚动速度（如从8秒改为10秒）
     3. 滚动函数自动变回"贝塞尔曲线"
   - **影响范围**：仅影响首次修改，后续修改正常

2、问题原因
   - **代码位置**：`UI/MainWindow.Keyframe.cs`
   - **根本原因**：
     * `SetScrollSpeed_Click()` 方法在修改滚动速度时
     * 同时设置了 `ScrollEasingType` 和 `IsLinearScrolling`
     * 使用的是字段 `_scrollEasingType` 的默认值（"Bezier"）
     * 而不是数据库中用户实际保存的设置
   - **类似问题**：`LoadScrollSpeedSettings()` 也存在相同逻辑

3、修复方案
   - **修改点1**：`SetScrollSpeed_Click()` (第950-953行)
     * 移除 `_keyframeManager.ScrollEasingType = _scrollEasingType;`
     * 移除 `_keyframeManager.IsLinearScrolling = _isLinearScrolling;`
     * 仅更新 `ScrollDuration`，不触碰缓动函数设置
   - **修改点2**：`LoadScrollSpeedSettings()` (第890-893行)
     * 移除对 `ScrollEasingType` 和 `IsLinearScrolling` 的设置
     * 这些属性在 `LoadScrollEasingSettings()` 中单独加载
   
4、设计原则
   - **职责分离**：
     * 滚动速度设置：只负责速度（Duration）
     * 滚动函数设置：只负责缓动类型（EasingType/IsLinearScrolling）
     * 两者互不干扰
   - **数据源唯一**：
     * 缓动函数设置应始终从数据库加载
     * 不使用硬编码的默认值覆盖用户设置

5、测试验证
   - ✅ 修改滚动速度不会影响滚动函数设置
   - ✅ 修改滚动函数不会影响滚动速度设置
   - ✅ 两者独立保存和加载
   - ✅ 程序重启后设置保持正确

V4.0.7
📁 文件夹顺序调整功能
1、支持文件夹顺序调整（两种方式）
   
   **方式一：拖拽排序** 🖱️
   - **操作方法**：按住文件夹并拖动到目标位置
   - **视觉反馈**：显示蓝色插入位置指示线
   - **完成排序**：松开鼠标即可
   - **技术特点**：
     * 扩展现有拖拽系统，支持 TreeItemType.Folder
     * 文件只能拖到文件上，文件夹只能拖到文件夹上
     * 轻量级UI更新，避免重新加载整个TreeView
   
   **方式二：右键菜单** 📋
   - **操作方法**：右键点击文件夹 → 选择"⬆️ 上移"或"⬇️ 下移"
   - **智能边界**：
     * 第一个文件夹：自动禁用上移
     * 最后一个文件夹：自动禁用下移
   - **即时反馈**：状态栏显示操作结果
   - **新增方法**：
     * `MoveFolderUp()`：文件夹上移一位
     * `MoveFolderDown()`：文件夹下移一位
   
   **共通技术实现**：
   - **数据库层**：
     * 新增 `UpdateFoldersOrder()` 方法批量更新文件夹排序
     * 利用 EF Core 自动变更跟踪机制
     * 自动更新所有文件夹的 OrderIndex 字段
   - **UI更新优化**：
     * 新增 `UpdateFolderTreeItemOrder()` 方法
     * 内存中重新排序，无需重新加载数据
     * 保持文件夹的展开/折叠状态
   - **核心方法**：
     * `ReorderFolders()`：处理拖拽排序逻辑
     * 交换位置并重新计算所有OrderIndex
     * 确保数据一致性
   
   **用户体验**：
   - ✅ 两种方式任选，灵活便捷
   - ✅ 直观的视觉反馈
   - ✅ 立即生效，无延迟
   - ✅ 自动保存到数据库
   - ✅ 边界保护，防止误操作

V4.0.6
📝 文本编辑器交互优化
1、优化文本框删除方式
   - 移除工具栏上的实体删除按钮（减少UI占用）
   - 添加右键菜单删除功能
     * 右键文本框 → 显示菜单 → 选择"🗑 删除文本框"
     * 自动选中当前文本框后显示菜单
   - 添加DEL快捷键删除
     * 选中文本框后按DEL键即可删除
     * 智能判断：仅在文本框未获得焦点时触发（避免干扰文本编辑）
   - 删除逻辑统一化：右键菜单、DEL键、代码调用共用同一方法

2、优化文本框选中交互体验
   - **单击文本区域即可选中**（不再需要精确点击边缘）
     * 原问题：点击文本区域直接进入编辑模式，难以选中文本框
     * 新方案：单击任意位置先选中，双击进入编辑模式
   - **双击进入编辑模式**
     * 双击间隔：500ms
     * 双击后自动全选文本，方便快速修改
   - 技术实现：
     * TextBox默认IsHitTestVisible=false，让鼠标事件穿透到外层
     * 进入编辑模式时才启用TextBox的鼠标交互
     * 退出编辑模式后恢复事件穿透状态
   - 用户体验改善：
     * 选中更容易：点击任意位置都能选中
     * 拖拽更顺畅：选中后可立即拖动
     * 编辑更直观：双击进入编辑，单击退出

3、优化字号调整步长
   - 滚轮调整：步长从5改为2（更精细的控制）
   - 按钮调整：增大/减小字号按钮步长也从5改为2
   - 保持一致性：所有字号调整方式使用相同步长

4、文本框交互逻辑全面优化 ⭐
   **新建文本框行为**：
   - 创建后自动进入编辑模式（全选占位符"双击编辑文字"）
   - 可直接输入文字替换占位符，无需手动选择
   
   **双击编辑智能判断**：
   - 占位符状态：双击全选文本（方便快速替换）
   - 已有内容：双击定位光标到末尾（保持光标闪动，方便继续编辑）
   - 新建文本框首次双击：全选（方便快速修改）
   
   **快捷键支持**：
   - `Enter` 或 `F2`：进入编辑模式（智能判断是否全选）
   - `Delete`：删除选中的文本框
   - `Esc`：退出编辑模式，返回选中状态
   
   **交互流程优化**：
   ```
   1. 新建 → 自动全选占位符 → 直接输入
   2. 选中 → 双击/Enter/F2 → 智能编辑（全选或定位光标）
   3. 编辑中 → Esc → 退出编辑
   4. 选中 → Del → 删除
   ```
   
   **技术实现**：
   - 添加 `IsNewlyCreated` 标记区分新建和已有文本框
   - `EnterEditMode(selectAll)` 参数控制是否全选
   - 光标定位：`SelectionStart/SelectionLength` 控制光标位置
   - 智能判断：根据占位符状态和新建标记自动选择行为

5、优化光标显示 🎨
   - **问题**：默认黑色光标在深色背景上看不见
   - **解决方案**：设置光标为亮蓝色 (#0096FF)
   - **效果**：任何背景（黑色、白色、彩色）下都清晰可见
   - **技术实现**：TextBox.CaretBrush 属性设置

6、修复缩略图和投影包含编辑框装饰元素的问题 🖼️
   - **问题现象**：
     * 保存缩略图时，文本框的边框、拖拽手柄等UI装饰会被保存进去
     * 投影时，文本框的编辑装饰元素也会被投影到外接显示器上
   - **期望效果**：缩略图和投影应该只显示纯净的文本内容，不包含编辑状态的UI元素
   - **解决方案**：
     * 渲染前：隐藏所有文本框的装饰元素
       - 边框（_border.BorderBrush → Transparent）
       - 选择框（_selectionRect.Visibility → Collapsed）
       - 拖拽手柄（_resizeThumb.Visibility → Collapsed）
       - 清除焦点（隐藏光标）
     * 强制更新布局（UpdateLayout），确保隐藏效果生效
     * 渲染后：恢复装饰元素的显示状态
     * 异常保护：try-finally 确保即使渲染失败也会恢复状态
   - **新增方法**（DraggableTextBox）：
     * `HideDecorations()`：隐藏UI装饰元素
     * `RestoreDecorations()`：恢复UI装饰元素
   - **应用场景**：
     * `GenerateThumbnail()`：保存缩略图时
     * `UpdateTextEditorProjection()`：更新文本编辑器投影时
   - **用户体验**：
     * 缩略图更美观专业（无多余UI元素）
     * 投影显示纯净内容（观众看不到编辑界面）
     * 便于快速预览幻灯片实际显示效果
     * 不影响正常编辑时的视觉反馈

V4.0.5
1、修复关键帧录制"最后一帧-第一帧"卡死问题（死锁）
   - **根本原因**：async/await死锁
   - **问题场景**：录制循环到第一帧时，停止录制命令 + Task.Delay(50)
   - **死锁原因**：
     * await command.ExecuteAsync(null) 在UI线程执行
     * await Task.Delay(50) 需要UI线程来完成continuation
     * 但UI线程被前面的命令锁住 → 死锁
   - **修复方案**：使用 ConfigureAwait(false)
     * await command.ExecuteAsync(null).ConfigureAwait(false)
     * await Task.Delay(50).ConfigureAwait(false)
     * 避免强制回到UI线程，防止死锁
   - **调试信息**：详细记录循环检测、录制停止、跳转流程
2、添加关键帧录制调试信息（定位问题的基础）
   - KeyframeNavigator: 详细记录循环检测、录制停止流程
   - 记录最后一帧时间的耗时统计
   - 停止录制命令的执行耗时
   - 跳转到第一帧的详细步骤和耗时
   - RecordKeyframeTimeAsync: 记录服务调用耗时
   - 便于定位录制系统卡死的具体环节

V4.0.4
🎮 渲染性能优化升级
1、添加GPU加速支持框架
   - 新增GPUContext管理器，自动检测GPU可用性
   - 智能适配：SkiaSharp GPU可用则启用，否则使用CPU高性能模式
   - 支持OpenGL/Direct3D后端（需要系统环境支持）
   - 启动时显示渲染模式状态
2、CPU高性能模式（默认）
   - **WPF环境特性**：WPF默认无OpenGL上下文，SkiaSharp GPU加速难以启用
   - **最优方案**：CPU SIMD优化 + WPF自身GPU合成
   - **性能优势**：
     * SkiaSharp CPU模式已使用SIMD指令（SSE2/AVX）并行处理
     * WPF自动使用DirectX GPU合成最终渲染结果
     * 避免CPU↔GPU数据传输开销（比强制SkiaSharp GPU更高效）
   - **实测性能**：缩放耗时26-53ms（已是CPU模式最优）
3、智能降级机制
   - GPU初始化失败：自动使用CPU高性能模式
   - GPU渲染失败：自动fallback到CPU渲染
   - 运行时GPU错误：自动重置GPU上下文
4、变色效果策略
   - 缩放：CPU SIMD优化（SkiaSharp ScalePixels）
   - 变色：CPU逐像素处理（逻辑复杂，智能背景检测）
   - WPF合成：自动使用GPU渲染到屏幕
5、技术说明
   - **为什么不是纯GPU加速？**
     * WPF应用默认无OpenGL渲染上下文
     * 强制创建GPU上下文需要额外窗口（影响架构）
     * WPF已有完整的DirectX GPU渲染管线
     * CPU处理 + WPF GPU合成 = 最佳性能平衡
   - **依赖包**：SkiaSharp.Views.Desktop.Common, SkiaSharp.NativeAssets.Win32
   - **内存管理**：及时释放图片资源，避免内存泄漏

V4.0.3
1、回归完全同步方案（移除所有节流和快速预览）
   - 问题总结：
     * 智能节流方案：快速预览+延迟渲染，虽然流畅但存在"模糊→清晰"过程
     * 缓存策略复杂：级别对齐、动态延迟，实际使用中效果不理想
     * 用户需求：宁可轻微卡顿，也要保证主屏幕和投影屏幕**完全同步**
   - 回归方案：
     * 移除所有节流定时器（_zoomThrottleTimer）
     * 移除快速预览逻辑（ApplyQuickZoomPreview）
     * 移除缓存对齐策略（ZOOM_STEP）
     * 每次缩放立即触发高质量渲染（PreRenderProjectionAsync）
     * 依靠IMemoryCache自然缓存减少重复渲染
   - 效果：主屏幕和投影屏幕完全同步，显示一致，无延迟，无模糊
2、修复切换图片后缩放状态未重置的问题
   - 根因：LoadImage()中没有重置currentZoom和imageProcessor.ZoomRatio
   - 修复：加载新图片时自动重置缩放为1.0
   - 效果：切换图片后显示恢复到默认缩放状态

V4.0.2
1、修复缩放纵横比错误（只缩放高度，宽度固定）
   - 根因：正常模式宽度固定为画布宽度，只缩放高度
   - 修复：宽度和高度等比缩放，保持纵横比（与Python版本一致）
2、添加投影缩放性能详细调试信息
   - 添加每个环节的耗时统计（缩放、转换、缓存等）
   - 区分缓存命中和缓存未命中的情况
   - 便于定位投影缩放不流畅的性能瓶颈

V4.0.1
修复变色逻辑，自动开启关闭不正确的问题。各种异步才做改为同步

V4.0.0
SkiaSharp重构图片库调用

V3.0.8
1、修复主屏幕缩放时投影屏幕不同步的问题
   - 根因：UI层ScaleTransform缩放未同步到ImageProcessor和ProjectionManager
   - 修复：Ctrl+滚轮缩放时同步更新ImageProcessor.ZoomRatio并触发投影更新
   - 添加完整调试信息，便于追踪缩放流程
   - 原图模式正确禁用缩放功能（与Python版本一致）
2、修复双重缩放导致的拉伸变形问题
   - 根因：同时使用UI层ScaleTransform和ImageProcessor.ZoomRatio导致双重缩放
   - 修复：正常模式只用ImageProcessor渲染缩放，原图模式只用UI层ScaleTransform
   - 缩放精确，无拉伸变形

V3.0.7
1、异步改为同步，继续优化性能
2、默认滚动时间改为9秒，默认滚动动画改为线性
3、添加切换图片和加载图片的详细性能调试信息
4、添加投影渲染的详细性能调试信息，定位投影卡顿原因
5、添加关键帧跳转的详细性能调试信息
6、实现投影智能预渲染：加载图片后后台异步预渲染投影缓存
   - 首次跳转关键帧不再卡顿（833ms → 5ms）
   - 耗时的渲染操作在后台线程完成，不阻塞UI
   - 防止重复预渲染，避免资源浪费
   存档，下一步将采用SkiaSharp图片工具

2025.10.16
--------------------------
V3.0.6
1、项目的幻灯片修改内容，更新投影没反应的问题修复
2、关键执行的时候，红色线变绿线。

V3.0.4
1、新增智能预缓存功能
   - 原图循环模式：自动预缓存相似图片，实现秒切换
   - 原图顺序模式：自动预缓存后续10张图片，连续浏览流畅
   - 关键帧模式：图片已在内存，切换极速
   - 精准预测策略，不乱猜不乱缓存，缓存命中率接近100%

V3.0.3
1、优化各种切换逻辑BUG

V3.0.2
1、新增子项目功能
2、优化富文本功能

V3.0.1
1、文本编辑器新增"退出编辑"按钮，可以随时返回图片/视频浏览模式
2、退出时自动检测未保存更改，提示用户保存

2025.10.15
--------------------------
V3.0
1、修复原图循环状态，不同图片切换不更新的问题
2、新增文本编辑功能


2025.10.15
--------------------------
V2.5.9
1、尝试解决视频播放小黑窗闪烁问题

V2.6
2、新增"联系作者"功能，包含微信联系和捐赠赞助两个选项，并排显示两张二维码
3、联系按钮采用淡橙色静态配色（#FFE0B2），与整体UI协调且醒目
5、新增文件夹自定义高亮色功能：右键文件夹菜单"标记高亮色"，调用系统内置颜色选择器
6、文件夹高亮颜色优先显示自定义颜色，未设置时使用默认颜色池（10色循环）
7、搜索结果中的文件夹标签颜色实时同步自定义设置

2025.10.14
--------------------------
V2.5.8
1、彻底找到播放视频有小黑窗放大的现象过程
2、新增选中文件透明弹窗显示文件全名
3、禁用文件导航栏底部水平滚动条
4、实现全局热键功能，软件后台也能响应按键pgup pgdown F2 ESC
5、输出文件名改为"Canvas Cast.exe"
6、修复主屏幕播放切换到投影播放功能失效的问题
7、删除菜单栏 热键按钮
8、视频小黑窗问题，还是有待优化


2025.10.13
--------------------------
V2.5.5 正式发布
V2.5.6 修复视频播放偶尔没有画面问题，注释调试信息
V2.5.7 增加自定义字号，设置文件夹，文件大小，搜索结果，文件导航栏宽度持久化